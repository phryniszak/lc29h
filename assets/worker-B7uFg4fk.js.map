{"version":3,"file":"worker-B7uFg4fk.js","sources":["../src/js/worker.js"],"sourcesContent":["const opfsRoot = await navigator.storage.getDirectory();\nconst textEncoder = new TextEncoder();\n\n// _my_.uiPaneFile.#worker.postMessage({ operation: \"getDirList\"})\n// some operations can fail during write operation\n// TODO: add some locking mechanism\n\nonmessage = async (e) => {\n\n    switch (e.data?.operation) {\n        case \"write\":\n            await write(e.data.file, e.data.str, e.data.dir);\n            return;\n        case \"deleteAll\":\n            await deleteAll();\n            // send it back to re read directories\n            postMessage({ operation: \"deleteAll\" });\n            return;\n        case \"getDirList\":\n            await listDirectoriesInRoot();\n            return;\n\n    }\n\n    console.log(\"Worker: Unknown message:\", e.data);\n};\n\n/**\n *\n * @returns\n */\nasync function isAnyFolderExists() {\n    try {\n        // Iterate through the entries in the directory\n        for await (const entry of opfsRoot.values()) {\n            console.log(\"Entry:\", entry);\n            if (entry.kind === \"directory\") {\n                console.log(`Folder found: ${entry.name}`);\n                return true; // Folder found\n            }\n        }\n\n        // console.log('No folders found');\n        return false; // No folders found\n    } catch (error) {\n        console.error(\"Error accessing file system:\", error);\n        return false;\n    }\n}\n\n/**\n *\n */\nasync function deleteAll() {\n    if (await isAnyFolderExists())\n        await opfsRoot.remove({ recursive: true });\n}\n\n/**\n *\n * @param {*} file\n * @param {*} str\n */\nasync function write(file, str, dir) {\n\n    if (dir == undefined) {\n        console.error(\"dir not defined\");\n        return;\n    }\n\n    const sessionDirHandle = await opfsRoot.getDirectoryHandle(dir, { create: true });\n    const fileHandle = await sessionDirHandle.getFileHandle(file, { create: true });\n    try {\n\n        await navigator.locks.request(\"createSyncAccessHandle\", async () => {\n            // The lock has been acquired.\n            const accessHandle = await fileHandle.createSyncAccessHandle();\n            // The current size of the file\n            const size = accessHandle.getSize();\n            // Encode content to write to the file.\n            const content = textEncoder.encode(str);\n            // Write the content at the beginning of the file.\n            accessHandle.write(content, { at: size });\n            // Persist changes to disk.\n            // accessHandle.flush();\n            // Bear in mind that you only need to call this method if you need the changes\n            // committed to disk at a specific time, otherwise you can leave the underlying\n            // operating system to handle this when it sees fit, which should be OK in most cases.\n            // Always close FileSystemSyncAccessHandle if done.\n            accessHandle.close();\n            // Now the lock will be released.\n        });\n\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\n\n/**\n * list directories with newest on the top (descending order)\n */\nasync function listDirectoriesInRoot() {\n\n    // Create an async generator to iterate over the entries in the directory\n    async function* getEntries(dirHandle) {\n        for await (const entry of dirHandle.values()) {\n            yield entry;\n        }\n    }\n\n    // Array to hold the names of the directories\n    const directories = [];\n\n    try {\n        // Iterate over the entries and check if they are directories\n        for await (const entry of getEntries(opfsRoot)) {\n            if (entry.kind === \"directory\") {\n                directories.push(entry.name);\n            }\n        }\n    } catch (error) {\n        console.error(\"Error accessing file system:\", error);\n    }\n\n    // Log the directories to the console\n    // console.log(\"Directories:\", directories);\n    // sort newest on the top\n    directories.sort().reverse();\n    // console.log(\"Directories sorted:\", directories);\n    // console.log(parseInt(directories[0], 16));\n    // console.log(new Date(parseInt(directories[0], 16)));\n    postMessage({ operation: \"getDirList\", directories: directories });\n}"],"names":[],"mappings":"AAAA,MAAM,WAAW,MAAM,UAAU,QAAQ,aAAc;AACvD,MAAM,cAAc,IAAI,YAAa;AAMrC,YAAY,OAAO,MAAM;AAErB,UAAQ,EAAE,MAAM,WAAS;AAAA,IACrB,KAAK;AACD,YAAM,MAAM,EAAE,KAAK,MAAM,EAAE,KAAK,KAAK,EAAE,KAAK,GAAG;AAC/C;AAAA,IACJ,KAAK;AACD,YAAM,UAAW;AAEjB,kBAAY,EAAE,WAAW,aAAa;AACtC;AAAA,IACJ,KAAK;AACD,YAAM,sBAAuB;AAC7B;AAAA,EAEZ;AAEI,UAAQ,IAAI,4BAA4B,EAAE,IAAI;AAClD;AAMA,eAAe,oBAAoB;AAC/B,MAAI;AAEA,qBAAiB,SAAS,SAAS,UAAU;AACzC,cAAQ,IAAI,UAAU,KAAK;AAC3B,UAAI,MAAM,SAAS,aAAa;AAC5B,gBAAQ,IAAI,iBAAiB,MAAM,IAAI,EAAE;AACzC,eAAO;AAAA,MACvB;AAAA,IACA;AAGQ,WAAO;AAAA,EACV,SAAQ,OAAO;AACZ,YAAQ,MAAM,gCAAgC,KAAK;AACnD,WAAO;AAAA,EACf;AACA;AAKA,eAAe,YAAY;AACvB,MAAI,MAAM,kBAAmB;AACzB,UAAM,SAAS,OAAO,EAAE,WAAW,KAAI,CAAE;AACjD;AAOA,eAAe,MAAM,MAAM,KAAK,KAAK;AAEjC,MAAI,OAAO,QAAW;AAClB,YAAQ,MAAM,iBAAiB;AAC/B;AAAA,EACR;AAEI,QAAM,mBAAmB,MAAM,SAAS,mBAAmB,KAAK,EAAE,QAAQ,MAAM;AAChF,QAAM,aAAa,MAAM,iBAAiB,cAAc,MAAM,EAAE,QAAQ,MAAM;AAC9E,MAAI;AAEA,UAAM,UAAU,MAAM,QAAQ,0BAA0B,YAAY;AAEhE,YAAM,eAAe,MAAM,WAAW,uBAAwB;AAE9D,YAAM,OAAO,aAAa,QAAS;AAEnC,YAAM,UAAU,YAAY,OAAO,GAAG;AAEtC,mBAAa,MAAM,SAAS,EAAE,IAAI,KAAI,CAAE;AAOxC,mBAAa,MAAO;AAAA,IAEhC,CAAS;AAAA,EAET,SACW,OAAO;AACV,YAAQ,MAAM,KAAK;AAAA,EAC3B;AACA;AAKA,eAAe,wBAAwB;AAGnC,kBAAgB,WAAW,WAAW;AAClC,qBAAiB,SAAS,UAAU,UAAU;AAC1C,YAAM;AAAA,IAClB;AAAA,EACA;AAGI,QAAM,cAAc,CAAE;AAEtB,MAAI;AAEA,qBAAiB,SAAS,WAAW,QAAQ,GAAG;AAC5C,UAAI,MAAM,SAAS,aAAa;AAC5B,oBAAY,KAAK,MAAM,IAAI;AAAA,MAC3C;AAAA,IACA;AAAA,EACK,SAAQ,OAAO;AACZ,YAAQ,MAAM,gCAAgC,KAAK;AAAA,EAC3D;AAKI,cAAY,KAAM,EAAC,QAAS;AAI5B,cAAY,EAAE,WAAW,cAAc,YAAwB,CAAE;AACrE;"}